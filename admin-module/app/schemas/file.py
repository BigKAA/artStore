"""
Admin Module - File Registry Schemas.

Sprint 15.2: Pydantic schemas для file registry API endpoints.

Schemas для:
- Регистрация файла при upload (POST /api/v1/files)
- Получение метаданных файла (GET /api/v1/files/{file_id})
- Обновление при финализации (PUT /api/v1/files/{file_id})
- Удаление файла (DELETE /api/v1/files/{file_id})
"""

from datetime import datetime
from typing import Optional
from uuid import UUID

from pydantic import BaseModel, Field, field_validator, model_validator

from app.models.file import RetentionPolicy


# ==================== Request Schemas ====================


class FileRegisterRequest(BaseModel):
    """
    Запрос на регистрацию нового файла в file registry.

    Используется Ingester Module после успешной загрузки файла в Storage Element.

    Sprint 15.2: POST /api/v1/files
    """

    file_id: UUID = Field(
        ...,
        description="UUID файла (generated by Storage Element)"
    )

    original_filename: str = Field(
        ...,
        min_length=1,
        max_length=500,
        description="Оригинальное имя файла при загрузке"
    )

    storage_filename: str = Field(
        ...,
        min_length=1,
        max_length=500,
        description="Имя файла в Storage Element"
    )

    file_size: int = Field(
        ...,
        ge=0,
        description="Размер файла в байтах"
    )

    checksum_sha256: str = Field(
        ...,
        min_length=64,
        max_length=64,
        description="SHA-256 checksum файла"
    )

    content_type: Optional[str] = Field(
        None,
        max_length=255,
        description="MIME type файла"
    )

    description: Optional[str] = Field(
        None,
        max_length=1000,
        description="Описание файла"
    )

    retention_policy: RetentionPolicy = Field(
        ...,
        description="Политика хранения: temporary или permanent"
    )

    ttl_expires_at: Optional[datetime] = Field(
        None,
        description="Дата истечения TTL (для temporary файлов)"
    )

    ttl_days: Optional[int] = Field(
        None,
        ge=1,
        le=365,
        description="Количество дней TTL (1-365)"
    )

    storage_element_id: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="ID Storage Element где хранится файл"
    )

    storage_path: str = Field(
        ...,
        min_length=1,
        max_length=1000,
        description="Полный путь к файлу в Storage Element"
    )

    compressed: bool = Field(
        False,
        description="Флаг сжатия файла"
    )

    compression_algorithm: Optional[str] = Field(
        None,
        max_length=20,
        description="Алгоритм сжатия: gzip, brotli"
    )

    original_size: Optional[int] = Field(
        None,
        ge=0,
        description="Оригинальный размер до сжатия"
    )

    uploaded_by: Optional[str] = Field(
        None,
        max_length=100,
        description="Client ID или User ID загрузившего"
    )

    upload_source_ip: Optional[str] = Field(
        None,
        max_length=45,
        description="IP адрес загрузки"
    )

    user_metadata: Optional[dict] = Field(
        None,
        description="Пользовательские метаданные (JSON)"
    )

    @field_validator('checksum_sha256')
    @classmethod
    def validate_checksum(cls, v: str) -> str:
        """Валидация SHA-256 checksum (64 hex символа)."""
        if not all(c in '0123456789abcdefABCDEF' for c in v):
            raise ValueError('Checksum must be valid hexadecimal string')
        return v.lower()

    @model_validator(mode='after')
    def validate_retention_policy_with_ttl(self) -> 'FileRegisterRequest':
        """
        Валидация consistency между retention_policy и ttl_*.

        Правила:
        - temporary → ttl_expires_at и ttl_days ОБЯЗАТЕЛЬНЫ
        - permanent → ttl_expires_at и ttl_days должны быть None

        Note: model_validator с mode='after' выполняется ПОСЛЕ парсинга всех полей,
        поэтому ttl_expires_at уже datetime объект, а не строка.
        """
        if self.retention_policy == RetentionPolicy.TEMPORARY:
            if not self.ttl_expires_at or not self.ttl_days:
                raise ValueError(
                    'ttl_expires_at and ttl_days are required for temporary files'
                )
        elif self.retention_policy == RetentionPolicy.PERMANENT:
            if self.ttl_expires_at or self.ttl_days:
                raise ValueError(
                    'ttl_expires_at and ttl_days must be None for permanent files'
                )

        return self

    model_config = {
        "json_schema_extra": {
            "example": {
                "file_id": "550e8400-e29b-41d4-a716-446655440000",
                "original_filename": "document.pdf",
                "storage_filename": "550e8400-e29b-41d4-a716-446655440000.pdf",
                "file_size": 1048576,
                "checksum_sha256": "a" * 64,
                "content_type": "application/pdf",
                "description": "Important document",
                "retention_policy": "temporary",
                "ttl_expires_at": "2024-02-01T00:00:00Z",
                "ttl_days": 30,
                "storage_element_id": "storage-element-01",
                "storage_path": "/files/550e8400-e29b-41d4-a716-446655440000.pdf",
                "compressed": False,
                "uploaded_by": "service-account-id",
                "upload_source_ip": "10.0.0.1",
                "user_metadata": {"department": "legal", "category": "contract"}
            }
        }
    }


class FileUpdateRequest(BaseModel):
    """
    Запрос на обновление файла (финализация).

    Используется Ingester Module при Two-Phase Commit для обновления:
    - retention_policy: temporary → permanent
    - storage_element_id: edit_se → rw_se
    - finalized_at: timestamp

    Sprint 15.2: PUT /api/v1/files/{file_id}
    """

    retention_policy: Optional[RetentionPolicy] = Field(
        None,
        description="Новая политика хранения (для финализации: permanent)"
    )

    storage_element_id: Optional[str] = Field(
        None,
        min_length=1,
        max_length=255,
        description="Новый ID Storage Element (для финализации)"
    )

    storage_path: Optional[str] = Field(
        None,
        min_length=1,
        max_length=1000,
        description="Новый путь к файлу"
    )

    finalized_at: Optional[datetime] = Field(
        None,
        description="Timestamp финализации"
    )

    description: Optional[str] = Field(
        None,
        max_length=1000,
        description="Обновленное описание"
    )

    user_metadata: Optional[dict] = Field(
        None,
        description="Обновленные метаданные"
    )

    model_config = {
        "json_schema_extra": {
            "example": {
                "retention_policy": "permanent",
                "storage_element_id": "storage-element-02",
                "storage_path": "/files/550e8400-e29b-41d4-a716-446655440000.pdf",
                "finalized_at": "2024-01-15T10:30:00Z"
            }
        }
    }


# ==================== Response Schemas ====================


class FileResponse(BaseModel):
    """
    Ответ с метаданными файла.

    Используется для:
    - GET /api/v1/files/{file_id}
    - POST /api/v1/files (после регистрации)
    - PUT /api/v1/files/{file_id} (после обновления)
    """

    file_id: UUID
    original_filename: str
    storage_filename: str
    file_size: int
    checksum_sha256: str
    content_type: Optional[str] = None
    description: Optional[str] = None

    # Retention Policy
    retention_policy: RetentionPolicy
    ttl_expires_at: Optional[datetime] = None
    ttl_days: Optional[int] = None
    finalized_at: Optional[datetime] = None

    # Storage Location
    storage_element_id: str
    storage_path: str

    # Compression
    compressed: bool
    compression_algorithm: Optional[str] = None
    original_size: Optional[int] = None

    # Ownership and audit
    uploaded_by: Optional[str] = None
    upload_source_ip: Optional[str] = None
    user_metadata: Optional[dict] = None

    # Timestamps
    created_at: datetime
    updated_at: datetime

    # Deletion tracking
    deleted_at: Optional[datetime] = None
    deletion_reason: Optional[str] = None

    # Computed properties
    is_deleted: bool = Field(
        False,
        description="Soft delete flag"
    )
    is_finalized: bool = Field(
        False,
        description="Финализирован ли файл"
    )
    is_temporary: bool = Field(
        True,
        description="Является ли файл временным"
    )

    model_config = {
        "from_attributes": True,  # Pydantic v2: было orm_mode=True
        "json_schema_extra": {
            "example": {
                "file_id": "550e8400-e29b-41d4-a716-446655440000",
                "original_filename": "document.pdf",
                "storage_filename": "550e8400-e29b-41d4-a716-446655440000.pdf",
                "file_size": 1048576,
                "checksum_sha256": "a" * 64,
                "content_type": "application/pdf",
                "description": "Important document",
                "retention_policy": "temporary",
                "ttl_expires_at": "2024-02-01T00:00:00Z",
                "ttl_days": 30,
                "finalized_at": None,
                "storage_element_id": "storage-element-01",
                "storage_path": "/files/550e8400-e29b-41d4-a716-446655440000.pdf",
                "compressed": False,
                "compression_algorithm": None,
                "original_size": None,
                "uploaded_by": "service-account-id",
                "upload_source_ip": "10.0.0.1",
                "user_metadata": {"department": "legal"},
                "created_at": "2024-01-01T10:00:00Z",
                "updated_at": "2024-01-01T10:00:00Z",
                "deleted_at": None,
                "deletion_reason": None,
                "is_deleted": False,
                "is_finalized": False,
                "is_temporary": True
            }
        }
    }


class FileListResponse(BaseModel):
    """
    Ответ со списком файлов.

    Используется для GET /api/v1/files (с pagination).
    """

    files: list[FileResponse] = Field(
        default_factory=list,
        description="Список файлов"
    )

    total: int = Field(
        0,
        ge=0,
        description="Общее количество файлов"
    )

    page: int = Field(
        1,
        ge=1,
        description="Текущая страница"
    )

    page_size: int = Field(
        50,
        ge=1,
        le=1000,
        description="Размер страницы"
    )

    total_pages: int = Field(
        0,
        ge=0,
        description="Общее количество страниц"
    )

    model_config = {
        "json_schema_extra": {
            "example": {
                "files": [],
                "total": 100,
                "page": 1,
                "page_size": 50,
                "total_pages": 2
            }
        }
    }


class FileDeleteResponse(BaseModel):
    """
    Ответ на удаление файла.

    Используется для DELETE /api/v1/files/{file_id}.

    Note: Soft delete - файл помечается как удаленный,
    но физически остается в БД для audit trail.
    """

    file_id: UUID
    deleted_at: datetime
    deletion_reason: str = Field(
        ...,
        max_length=255,
        description="Причина удаления: manual, ttl_expired, gc_cleanup, finalized"
    )

    message: str = Field(
        "File marked as deleted successfully",
        description="Результат операции"
    )

    model_config = {
        "json_schema_extra": {
            "example": {
                "file_id": "550e8400-e29b-41d4-a716-446655440000",
                "deleted_at": "2024-01-15T10:30:00Z",
                "deletion_reason": "manual",
                "message": "File marked as deleted successfully"
            }
        }
    }
